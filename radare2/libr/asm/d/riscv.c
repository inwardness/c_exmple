// SDB-CGEN V2.0.2
// gcc -DMAIN=1 riscv.c ; ./a.out > riscv.h
#include <ctype.h>
#include <stdio.h>
#include <string.h>

struct kv { const char *name; const char *value; };
static const struct kv kvs[] = {
  {"rem","remainder of division"}, 
  {"c.sw","store word (32 bits) (compressed instruction)"}, 
  {"csrwi","write CSR, immediate"}, 
  {"lhu","load half-word (16 bits), unsigned"}, 
  {"c.ebreak","environment breakpoint (compressed instruction)"}, 
  {"c.srli","shift right logically by immediate (compressed instruction)"}, 
  {"fsub.d","floating-point subtract, double precision"}, 
  {"add","add"}, 
  {"amomin.w","atomic memory operation, signed integer minimum (32 bits)"}, 
  {"c.subw","subtract words (32 bits) (compressed instruction)"}, 
  {"fdiv.s","floating-point division, single precision"}, 
  {"amoxor.d","atomic memory operation,"}, 
  {"fence","memory and I/O fence"}, 
  {"csrrci","atomic read and clear immediate bit in CSR"}, 
  {"c.sd","store double word (64 bits) (compressed instruction)"}, 
  {"fsub.s","floating-point subtract, single precision"}, 
  {"ebreak","environment breakpoint"}, 
  {"fdiv.d","floating-point division, double precision"}, 
  {"c.beqz","branch if equal to zero (compressed instruction)"}, 
  {"bgtu","branch if greater than, unsigned"}, 
  {"srli","shift right logically by immediate"}, 
  {"divw","signed division of words (32 bits)"}, 
  {"c.swsp","store word (32 bits), SP relative (compressed instruction)"}, 
  {"amoxor.w","atomic memory operation,"}, 
  {"divu","unsigned division"}, 
  {"c.ldsp","load double word (64 bits), SP relative (compressed instruction)"}, 
  {"c.addi16sp","add signed immediate*16 to stack pointer (compressed instruction)"}, 
  {"frcsr","read fp control/status register"}, 
  {"amomaxu.d","atomic memory operation, unsigned integer maximum (64 bits)"}, 
  {"bgtz","branch if greater than zero"}, 
  {"hrts","hypervisor redirect trap to supervisor"}, 
  {"seqz","set if equal to zero"}, 
  {"mulw","multiply word (32 bits)"}, 
  {"amoadd.d","atomic memory operation, add (64 bits)"}, 
  {"fmadd.d","floating-point multiply-add, double precision"}, 
  {"c.flwsp","floating-point load, single precision, SP relative (compressed instruction)"}, 
  {"bltz","branch if less than zero"}, 
  {"frrm","read fp rounding mode"}, 
  {"amominu.w","atomic memory operation, unsigned integer minimum (32 bits)"}, 
  {"fsw","floating-point store word (single precision value)"}, 
  {"lui","load upper immediate"}, 
  {"bltu","branch if less than, unsigned"}, 
  {"c.mv","move (compressed instruction)"}, 
  {"amomaxu.w","atomic memory operation, unsigned integer maximum (32 bits)"}, 
  {"j","jump"}, 
  {"mulhsu","multiply signed*unsigned, high half"}, 
  {"div","signed division"}, 
  {"slt","set if less than"}, 
  {"fclass.d","classify floating point number, double precision"}, 
  {"fmadd.s","floating-point multiply-add, single precision"}, 
  {"lr.w","load reserved (32 bits)"}, 
  {"srlw","shift right logically (32 bits)"}, 
  {"mulh","multiply, high half"}, 
  {"amoadd.w","atomic memory operation, add (32 bits)"}, 
  {"fsd","floating-point store double"}, 
  {"sll","shift left logically"}, 
  {"or","bitwise OR"}, 
  {"fclass.s","classify floating point number, single precision"}, 
  {"c.ld","load double word (64 bits) (compressed instruction)"}, 
  {"neg","two's complement"}, 
  {"eret","environment return"}, 
  {"amominu.d","atomic memory operation, unsigned integer minimum (64 bits)"}, 
  {"c.addi","add immediate  (compressed instruction)"}, 
  {"fcvt.s.wu","convert to single from unsigned word (32 bits)"}, 
  {"csrrw","atomic read/write CSR"}, 
  {"csrrsi","atomic read and set immediate bit in CSR"}, 
  {"fmv.x.d","move integer register to double"}, 
  {"lr.d","load reserved (64 bits)"}, 
  {"csrrs","atomic read and set bit in CSR"}, 
  {"c.li","load immediate (compressed instruction)"}, 
  {"fmv.s.x","move single to integer register"}, 
  {"snez","set if not equal to zero"}, 
  {"bgeu","branch if greater than, unsigned"}, 
  {"ble","branch if less than or equal to"}, 
  {"c.lw","load word (32 bits) (compressed instruction)"}, 
  {"fld","floating-point load double"}, 
  {"ori","bitwise OR with immediate"}, 
  {"fmv.x.s","move integer register to double"}, 
  {"c.fld","floating-point load, double precision (compressed instruction)"}, 
  {"fsgnj.s","floating-point sign-injection, single precision"}, 
  {"fsgnjn.s","floating-point negated sign-injection, single precision"}, 
  {"fcvt.wu.d","convert to unsigned word (32 bits) from double"}, 
  {"c.j","jump (compressed instruction)"}, 
  {"c.slli","logical left shift by immediate (compressed instruction)"}, 
  {"csrrc","atomic read and clear bit in CSR"}, 
  {"sra","shift right arithmetically"}, 
  {"c.sdsp","store double word (64 bits), SP relative (compressed instruction)"}, 
  {"fcvt.d.wu","convert to double from unsigned word (32 bits)"}, 
  {"c.lui","load upper immediate (compressed instruction)"}, 
  {"srl","shift right logically"}, 
  {"bgez","branch if greater than or equal to zero"}, 
  {"c.lwsp","load word (32 bits), SP relative (compressed instruction)"}, 
  {"c.addw","add 32-bit words (compressed instruction)"}, 
  {"flw","floating-point load word"}, 
  {"sllw","shift left logically (32 bits)"}, 
  {"fsgnj.d","floating-point sign-injection, double precision"}, 
  {"blt","branch if less than"}, 
  {"sextw","two complement word"}, 
  {"remw","remainder of division (32 bits)"}, 
  {"sfence.vma","supervisor-mode fence for virtual memory"}, 
  {"remu","remainder of unsigned division"}, 
  {"c.flw","floating-point load, single precision (compressed instruction)"}, 
  {"sgtz","set if greater than zero"}, 
  {"fcvt.wu.s","convert to unsigned word (32 bits) from single"}, 
  {"li","load immediate"}, 
  {"lh","load half-word (16 bits)"}, 
  {"fsgnjn.d","floating-point negated sign-injection, double precision"}, 
  {"fence.i","instruction cache fence"}, 
  {"andi","bitwise and with immediate"}, 
  {"la","load address"}, 
  {"slliw","shift left logically by immediate (32 bits)"}, 
  {"lb","load byte"}, 
  {"beqz","branch if equal to zero"}, 
  {"sub","subtract"}, 
  {"ld","load double word (64 bits)"}, 
  {"mul","multiply"}, 
  {"fcvt.d.lu","convert to double from unsigned long (64 bits)"}, 
  {"slli","shift left logically by immediate"}, 
  {"fsrmi","swap fp rounding mode with immediate"}, 
  {"csrsi","set bits in CSR, immediate"}, 
  {"sw","store word (32 bits)"}, 
  {"rdtime","read real-time clock"}, 
  {"c.jalr","jump and link, register relative (compressed instruction)"}, 
  {"fnmsub.d","floating-point negated multiply-subtract, double precision"}, 
  {"lr","load reserved"}, 
  {"lw","load word (32 bits)"}, 
  {"fnmadd.d","floating-point negated multiply-add, double precision"}, 
  {"sfence.vm","supervisor-mode fence for virtual memory (Deprecated)"}, 
  {"slti","set if less than immediate"}, 
  {"c.fsw","floating-point store, single precision (compressed instruction)"}, 
  {"fmax.s","floating-point maximum, single precision"}, 
  {"csrc","clear bits in CSR"}, 
  {"c.jr","jump, register relative (compressed instruction)"}, 
  {"c.sub","subtract (compressed instruction)"}, 
  {"fnmsub.s","floating-point negated multiply-subtract, single precision"}, 
  {"c.xor","exclusive OR (compressed instruction)"}, 
  {"call","call far subroutine"}, 
  {"c.addiw","add immediate to 32-bit word (compressed instruction)"}, 
  {"sd","store double word (64 bits)"}, 
  {"remuw","remainder of unsigned division (32 bits)"}, 
  {"sb","store byte"}, 
  {"fcvt.lu.s","convert to unsigned long (64 bits) from single"}, 
  {"sc","store conditional"}, 
  {"c.srai","shift right arithmetically by immediate (compressed instruction)"}, 
  {"c.addi4spn","add unsigned immediate*4 to stack pointer (compressed instruction)"}, 
  {"jalr","jump and link (call); register-based"}, 
  {"sltz","set if less than zero"}, 
  {"c.fsd","floating-point store, double precision (compressed instruction)"}, 
  {"beq","branch if equal"}, 
  {"csrw","write CSR"}, 
  {"fnmadd.s","floating-point negated multiply-add, single precision"}, 
  {"csrs","set bits in CSR"}, 
  {"sh","store half-word (16 bits)"}, 
  {"sltu","set if less than, unsigned"}, 
  {"csrr","read CSR"}, 
  {"fmax.d","floating-point maximum, double precision"}, 
  {"fmin.d","floating-point minimum, double precision"}, 
  {"jr","jump register"}, 
  {"blez","branch if less than or equal to zero"}, 
  {"c.andi","bitwirse AND with immediate (compressed instruction)"}, 
  {"subw","subtract word (32 bits)"}, 
  {"c.bnez","branch if not equal to zero (compressed instruction)"}, 
  {"mv","copy"}, 
  {"bleu","branch if less than or equal to, unsigned"}, 
  {"srai","shift right arithmetically by immediate"}, 
  {"fcvt.lu.d","convert to unsigned long (64 bits) from double"}, 
  {"frflags","read fp exception flags"}, 
  {"sraiw","shift right arithmetically by immediate (32 bits)"}, 
  {"sraw","shift right arithmetically (32 bits)"}, 
  {"tail","tail call far-away subroutine"}, 
  {"fsflagsi","swap or write fp exception flags with immediate"}, 
  {"bne","branch if not equal"}, 
  {"fmin.s","floating-point minimum, single precision"}, 
  {"jal","jump and link (call)"}, 
  {"xori","exclusive or with immediate"}, 
  {"csrci","clear bits in CSR, immediate"}, 
  {"xor","exclusive or"}, 
  {"fsrm","swap fp rounding mode"}, 
  {"ecall","environment call"}, 
  {"lbu","load byte, unsigned"}, 
  {"auipc","add upper immediate to PC"}, 
  {"addi","add immediate"}, 
  {"feq.s","floating-point \""}, 
  {"rdcycleh","read cycle counter, high half"}, 
  {"fmul.s","floating-point multiply, single precision"}, 
  {"and","bitwise and"}, 
  {"addw","add 32-bit words"}, 
  {"not","one's complement"}, 
  {"fmv.d.x","move double to integer register"}, 
  {"amoswap.w","atomic memory operation, swap (32 bits)"}, 
  {"fadd.d","floating-point add, double precision"}, 
  {"c.fldsp","floating-point load, double precision, SP relative (compressed instruction)"}, 
  {"bnez","branch if not equal to zero"}, 
  {"wfi","wait for interrupt"}, 
  {"nop","no operation"}, 
  {"fcvt.s.w","convert to single from word (32 bits)"}, 
  {"fscsr","swap fp control/status register"}, 
  {"fcvt.w.s","convert to word (32 bits) from single"}, 
  {"c.and","bitwise AND (compressed instruction)"}, 
  {"fsflags","swap fp exception flags"}, 
  {"feq.d","floating-point \""}, 
  {"rdcycle","read cycle counter"}, 
  {"fmul.d","floating-point multiply, double precision"}, 
  {"flt.s","floating-point \""}, 
  {"amoswap.d","atomic memory operation, swap (64 bits)"}, 
  {"mulhu","multiply unsigned, high half"}, 
  {"fcvt.s.d","convert to single from double"}, 
  {"fcvt.w.d","convert to word (32 bits) from double"}, 
  {"mrth","machine redirect trap to hypervisor"}, 
  {"csrrwi","atomic read/write CSR with immediate"}, 
  {"sext","two complement"}, 
  {"fadd.s","floating-point add, single precision"}, 
  {"fcvt.s.l","convert to single from long (64 bits)"}, 
  {"flt.d","floating-point \""}, 
  {"negw","two's complement word"}, 
  {"bge","branch if greater than"}, 
  {"rdinstreth","read \""}, 
  {"c.or","bitwise OR (compressed instruction)"}, 
  {"fle.d","floating-point \""}, 
  {"srliw","shift right logically by immediate (32 bits)"}, 
  {"fmsub.d","floating-point multiply-subtract, double precision"}, 
  {"c.fswsp","floating-point store, single precision, SP relative (compressed instruction)"}, 
  {"fcvt.d.l","convert to double from long (64 bits)"}, 
  {"c.add","add (compressed instruction)"}, 
  {"mrts","machine redirect trap to supervisor"}, 
  {"rdinstret","read \""}, 
  {"bgt","branch if greater than"}, 
  {"fcvt.d.w","convert to double from word (32 bits)"}, 
  {"amoand.d","atomic memory operation, bitwise AND (64 bits)"}, 
  {"amoor.w","atomic memory operation, bitwise OR (32 bits)"}, 
  {"fsqrt.d","floating-point square root, double precision"}, 
  {"fcvt.d.s","convert to double from single"}, 
  {"sc.w","store conditional (32 bits)"}, 
  {"fcvt.l.d","convert to long (64 bits) from double"}, 
  {"ret","return from subroutine"}, 
  {"fsgnjx.d","floating-point XOR sign-injection, double precision"}, 
  {"lwu","load word (32 bits) unsigned"}, 
  {"fle.s","floating-point \""}, 
  {"fmsub.s","floating-point multiply-subtract, single precision"}, 
  {"amoand.w","atomic memory operation, bitwise AND (32 bits)"}, 
  {"fcvt.s.lu","convert to single from unsigned long (64 bits)"}, 
  {"fsqrt.s","floating-point square root, single precision"}, 
  {"amomax.w","atomic memory operation, signed integer maximum (32 bits)"}, 
  {"amoor.d","atomic memory operation, bitwise OR (64 bits)"}, 
  {"divuw","unsigned division of words (32 bits)"}, 
  {"sc.d","store conditional (64 bits)"}, 
  {"fcvt.l.s","convert to long (64 bits) from single"}, 
  {"rdtimeh","read real-time clock, high half"}, 
  {"amomin.d","atomic memory operation, signed integer minimum (64 bits)"}, 
  {"addiw","add immediate to 32-bit word"}, 
  {"c.jal","jump and link (compressed instruction)"}, 
  {"c.fsdsp","floating-point store, double precision, SP relative (compressed instruction)"}, 
  {"fsgnjx.s","floating-point XOR sign-injection, single precision"}, 
  {"amomax.d","atomic memory operation, signed integer maximum (64 bits)"}, 
  {"sltiu","set if less than immediate, unsigned"}, 
  {NULL, NULL}
};
// 0x95af170
// TODO
typedef int (*GperfForeachCallback)(void *user, const char *k, const char *v);
int gperf_riscv_foreach(GperfForeachCallback cb, void *user) {
  int i = 0; while (kvs[i].name) {
  cb (user, kvs[i].name, kvs[i].value);
  i++;}
  return 0;
}
const char *gperf_riscv_get(const char *s) {
  int i = 0; while (kvs[i].name) {
  if (!strcmp (s, kvs[i].name)) return kvs[i].value;
  i++;}
  return NULL;
}
#define sdb_hash_c_riscv(x,y) gperf_riscv_hash(x)
const unsigned int gperf_riscv_hash(const char *s) {
  int sum = strlen (s);
  while (*s) { sum += *s; s++; }
  return sum;
}
struct {const char *name;void *get;void *hash;void *foreach;} gperf_riscv = {
  .name = "riscv",
  .get = &gperf_riscv_get,
  .hash = &gperf_riscv_hash,
  .foreach = &gperf_riscv_foreach
};

#if MAIN
int main () {
	const char *s = ((char*(*)(char*))gperf_riscv.get)("foo");
	printf ("%s\n", s);
}
#endif
