<!DOCTYPE html>

<html lang="en">

<!-- Mirrored from shell-storm.org/x86doc/VPCMPQ_VPCMPUQ.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 Sep 2023 17:02:58 GMT -->
<head>
<meta charset="utf-8">
<title>VPCMPQ/VPCMPUQ—Compare Packed Integer Values into Mask </title>
<meta name="Description" content="VPCMPQ/VPCMPUQ—Compare Packed Integer Values into Mask " />
<meta content="VPCMPQ/VPCMPUQ, x64 opcodes, nasm opcode table, assembly opcode table, intel opcode reference, x86 opcode, instruction reference, assembly opcodes, intel semantics" name="keywords">
<meta name="Viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Robots" content="index,follow"/>
<link href="style.css" type="text/css" rel="stylesheet">
<script async src="../../www.googletagmanager.com/gtag/jsb2d6?id=G-NLNHL50HG5"></script>
<script src="https://shell-storm.org/assets/js/gtag.js"></script>
</head>
<body><a href="index.html">Back to opcode table</a>
<h1>VPCMPQ/VPCMPUQ—Compare Packed Integer Values into Mask</h1>
<table>
<tr>
<th>Opcode/Instruction</th>
<th>Op/En</th>
<th>64/32 bit Mode Support</th>
<th>CPUID Feature Flag</th>
<th>Description</th></tr>
<tr>
<td>
<p>EVEX.NDS.128.66.0F3A.W1 1F /r ib</p>
<p>VPCMPQ k1 {k2}, xmm2, xmm3/m128/m64bcst, imm8</p></td>
<td>FV</td>
<td>V/V</td>
<td>
<p>AVX512VL</p>
<p>AVX512F</p></td>
<td>Compare packed signed quadword integer values in xmm3/m128/m64bcst and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.</td></tr>
<tr>
<td>
<p>EVEX.NDS.256.66.0F3A.W1 1F /r ib</p>
<p>VPCMPQ k1 {k2}, ymm2, ymm3/m256/m64bcst, imm8</p></td>
<td>FV</td>
<td>V/V</td>
<td>
<p>AVX512VL</p>
<p>AVX512F</p></td>
<td>Compare packed signed quadword integer values in ymm3/m256/m64bcst and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.</td></tr>
<tr>
<td>
<p>EVEX.NDS.512.66.0F3A.W1 1F /r ib</p>
<p>VPCMPQ k1 {k2}, zmm2, zmm3/m512/m64bcst, imm8</p></td>
<td>FV</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Compare packed signed quadword integer values in zmm3/m512/m64bcst and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.</td></tr>
<tr>
<td>
<p>EVEX.NDS.128.66.0F3A.W1 1E /r ib</p>
<p>VPCMPUQ k1 {k2}, xmm2, xmm3/m128/m64bcst, imm8</p></td>
<td>FV</td>
<td>V/V</td>
<td>
<p>AVX512VL</p>
<p>AVX512F</p></td>
<td>Compare packed unsigned quadword integer values in xmm3/m128/m64bcst and xmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.</td></tr>
<tr>
<td>
<p>EVEX.NDS.256.66.0F3A.W1 1E /r ib</p>
<p>VPCMPUQ k1 {k2}, ymm2, ymm3/m256/m64bcst, imm8</p></td>
<td>FV</td>
<td>V/V</td>
<td>
<p>AVX512VL</p>
<p>AVX512F</p></td>
<td>Compare packed unsigned quadword integer values in ymm3/m256/m64bcst and ymm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.</td></tr>
<tr>
<td>
<p>EVEX.NDS.512.66.0F3A.W1 1E /r ib</p>
<p>VPCMPUQ k1 {k2}, zmm2, zmm3/m512/m64bcst, imm8</p></td>
<td>FV</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Compare packed unsigned quadword integer values in zmm3/m512/m64bcst and zmm2 using bits 2:0 of imm8 as a comparison predicate with writemask k2 and leave the result in mask register k1.</td></tr></table>
<h3>Instruction Operand Encoding</h3>
<table>
<tr>
<td>Op/En</td>
<td>Operand 1</td>
<td>Operand 2</td>
<td>Operand 3</td>
<td>Operand 4</td></tr>
<tr>
<td>FV</td>
<td>ModRM:reg (w)</td>
<td>EVEX.vvvv (r)</td>
<td>ModRM:r/m (r)</td>
<td>Imm8</td></tr></table>
<h2>Description</h2>
<p>Performs a SIMD compare of the packed integer values in the second source operand and the first source operand and returns the results of the comparison to the mask destination operand. The comparison predicate operand (immediate byte) specifies the type of comparison performed on each pair of packed values in the two source oper-ands. The result of each comparison is a single mask bit result of 1 (comparison true) or 0 (comparison false).</p>
<p>VPCMPQ/VPCMPUQ performs a comparison between pairs of signed/unsigned quadword integer values.</p>
<p>The first source operand (second operand) is a ZMM/YMM/XMM register. The second source operand can be a ZMM/YMM/XMM register or a 512/256/128-bit memory location or a 512-bit vector broadcasted from a 64-bit memory location. The destination operand (first operand) is a mask register k1. Up to 8/4/2 comparisons are performed with results written to the destination operand under the writemask k2.</p>
<p>The comparison predicate operand is an 8-bit immediate: bits 2:0 define the type of comparison to be performed. Bits 3 through 7 of the immediate are reserved. Compiler can implement the pseudo-op mnemonic listed in Table 5-10.</p>
<h2>Operation</h2>
<pre>
CASE (COMPARISON PREDICATE) OF
0: OP (cid:197) EQ;
1: OP (cid:197) LT;
2: OP (cid:197) LE;
3: OP (cid:197) FALSE;
4: OP (cid:197) NEQ;
5: OP (cid:197) NLT;
6: OP (cid:197) NLE;
7: OP (cid:197) TRUE;
ESAC;
</pre>
<strong>VPCMPQ (EVEX encoded versions)</strong>
<pre>
(KL, VL) = (2, 128), (4, 256), (8, 512)
FOR j (cid:197) 0 TO KL-1
    i (cid:197) j * 64
    IF k2[j] OR *no writemask*
        THEN
        IF (EVEX.b = 1) AND (SRC2 *is memory*)
            THEN CMP (cid:197) SRC1[i+63:i] OP SRC2[63:0];
            ELSE CMP (cid:197) SRC1[i+63:i] OP SRC2[i+63:i];
        FI;
        IF CMP = TRUE
            THEN DEST[j] (cid:197) 1;
            ELSE DEST[j] (cid:197) 0; FI;
        ELSE
        DEST[j] (cid:197) 0
        ; zeroing-masking only
    FI;
ENDFOR
DEST[MAX_KL-1:KL] (cid:197) 0
</pre>
<strong>VPCMPUQ (EVEX encoded versions)</strong>
<pre>
(KL, VL) = (2, 128), (4, 256), (8, 512)
FOR j (cid:197) 0 TO KL-1
    i (cid:197) j * 64
    IF k2[j] OR *no writemask*
        THEN
        IF (EVEX.b = 1) AND (SRC2 *is memory*)
            THEN CMP (cid:197) SRC1[i+63:i] OP SRC2[63:0];
            ELSE CMP (cid:197) SRC1[i+63:i] OP SRC2[i+63:i];
        FI;
        IF CMP = TRUE
            THEN DEST[j] (cid:197) 1;
            ELSE DEST[j] (cid:197) 0; FI;
        ELSE
        DEST[j] (cid:197) 0
        ; zeroing-masking only
    FI;
ENDFOR
DEST[MAX_KL-1:KL] (cid:197) 0
</pre>
<h2>Intel C/C++ Compiler Intrinsic Equivalent</h2>
<pre>
VPCMPQ __mmask8 _mm512_cmp_epi64_mask( __m512i a, __m512i b, int imm);
VPCMPQ __mmask8 _mm512_mask_cmp_epi64_mask(__mmask8 k, __m512i a, __m512i b, int imm);
VPCMPQ __mmask8 _mm512_cmp[eq|ge|gt|le|lt|neq]_epi64_mask( __m512i a, __m512i b);
VPCMPQ __mmask8 _mm512_mask_cmp[eq|ge|gt|le|lt|neq]_epi64_mask(__mmask8 k, __m512i a, __m512i b);
VPCMPUQ __mmask8 _mm512_cmp_epu64_mask( __m512i a, __m512i b, int imm);
VPCMPUQ __mmask8 _mm512_mask_cmp_epu64_mask(__mmask8 k, __m512i a, __m512i b, int imm);
VPCMPUQ __mmask8 _mm512_cmp[eq|ge|gt|le|lt|neq]_epu64_mask( __m512i a, __m512i b);
VPCMPUQ __mmask8 _mm512_mask_cmp[eq|ge|gt|le|lt|neq]_epu64_mask(__mmask8 k, __m512i a, __m512i b);
VPCMPQ __mmask8 _mm256_cmp_epi64_mask( __m256i a, __m256i b, int imm);
VPCMPQ __mmask8 _mm256_mask_cmp_epi64_mask(__mmask8 k, __m256i a, __m256i b, int imm);
VPCMPQ __mmask8 _mm256_cmp[eq|ge|gt|le|lt|neq]_epi64_mask( __m256i a, __m256i b);
VPCMPQ __mmask8 _mm256_mask_cmp[eq|ge|gt|le|lt|neq]_epi64_mask(__mmask8 k, __m256i a, __m256i b);
VPCMPUQ __mmask8 _mm256_cmp_epu64_mask( __m256i a, __m256i b, int imm);
VPCMPUQ __mmask8 _mm256_mask_cmp_epu64_mask(__mmask8 k, __m256i a, __m256i b, int imm);
VPCMPUQ __mmask8 _mm256_cmp[eq|ge|gt|le|lt|neq]_epu64_mask( __m256i a, __m256i b);
VPCMPUQ __mmask8 _mm256_mask_cmp[eq|ge|gt|le|lt|neq]_epu64_mask(__mmask8 k, __m256i a, __m256i b);
VPCMPQ __mmask8 _mm_cmp_epi64_mask( __m128i a, __m128i b, int imm);
VPCMPQ __mmask8 _mm_mask_cmp_epi64_mask(__mmask8 k, __m128i a, __m128i b, int imm);
VPCMPQ __mmask8 _mm_cmp[eq|ge|gt|le|lt|neq]_epi64_mask( __m128i a, __m128i b);
VPCMPQ __mmask8 _mm_mask_cmp[eq|ge|gt|le|lt|neq]_epi64_mask(__mmask8 k, __m128i a, __m128i b);
VPCMPUQ __mmask8 _mm_cmp_epu64_mask( __m128i a, __m128i b, int imm);
VPCMPUQ __mmask8 _mm_mask_cmp_epu64_mask(__mmask8 k, __m128i a, __m128i b, int imm);
VPCMPUQ __mmask8 _mm_cmp[eq|ge|gt|le|lt|neq]_epu64_mask( __m128i a, __m128i b);
VPCMPUQ __mmask8 _mm_mask_cmp[eq|ge|gt|le|lt|neq]_epu64_mask(__mmask8 k, __m128i a, __m128i b);
</pre>
<h2>SIMD Floating-Point Exceptions</h2>
<p>None</p>
<h2>Other Exceptions</h2>
<p>EVEX-encoded instruction, see Exceptions Type E4.</p>
</body>

<!-- Mirrored from shell-storm.org/x86doc/VPCMPQ_VPCMPUQ.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 Sep 2023 17:02:58 GMT -->
</html>
