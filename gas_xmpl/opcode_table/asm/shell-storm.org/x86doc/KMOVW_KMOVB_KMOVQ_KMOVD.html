<!DOCTYPE html>

<html lang="en">

<!-- Mirrored from shell-storm.org/x86doc/KMOVW_KMOVB_KMOVQ_KMOVD.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 Sep 2023 17:02:58 GMT -->
<head>
<meta charset="utf-8">
<title>KMOVW/KMOVB/KMOVQ/KMOVD—Move from and to Mask Registers </title>
<meta name="Description" content="KMOVW/KMOVB/KMOVQ/KMOVD—Move from and to Mask Registers " />
<meta content="KMOVW/KMOVB/KMOVQ/KMOVD, x64 opcodes, nasm opcode table, assembly opcode table, intel opcode reference, x86 opcode, instruction reference, assembly opcodes, intel semantics" name="keywords">
<meta name="Viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Robots" content="index,follow"/>
<link href="style.css" type="text/css" rel="stylesheet">
<script async src="../../www.googletagmanager.com/gtag/jsb2d6?id=G-NLNHL50HG5"></script>
<script src="https://shell-storm.org/assets/js/gtag.js"></script>
</head>
<body><a href="index.html">Back to opcode table</a>
<h1>KMOVW/KMOVB/KMOVQ/KMOVD—Move from and to Mask Registers</h1>
<table>
<tr>
<th>Opcode/Instruction</th>
<th>Op/En</th>
<th>64/32 bit Mode Support</th>
<th>CPUID Feature Flag</th>
<th>Description</th></tr>
<tr>
<td>VEX.L0.0F.W0 90 /r KMOVW k1, k2/m16</td>
<td>RM</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Move 16 bits mask from k2/m16 and store the result in k1.</td></tr>
<tr>
<td>VEX.L0.66.0F.W0 90 /r KMOVB k1, k2/m8</td>
<td>RM</td>
<td>V/V</td>
<td>AVX512DQ</td>
<td>Move 8 bits mask from k2/m8 and store the result in k1.</td></tr>
<tr>
<td>VEX.L0.0F.W1 90 /r KMOVQ k1, k2/m64</td>
<td>RM</td>
<td>V/V</td>
<td>AVX512BW</td>
<td>Move 64 bits mask from k2/m64 and store the result in k1.</td></tr>
<tr>
<td>VEX.L0.66.0F.W1 90 /r KMOVD k1, k2/m32</td>
<td>RM</td>
<td>V/V</td>
<td>AVX512BW</td>
<td>Move 32 bits mask from k2/m32 and store the result in k1.</td></tr>
<tr>
<td>VEX.L0.0F.W0 91 /r KMOVW m16, k1</td>
<td>MR</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Move 16 bits mask from k1 and store the result in m16.</td></tr>
<tr>
<td>VEX.L0.66.0F.W0 91 /r KMOVB m8, k1</td>
<td>MR</td>
<td>V/V</td>
<td>AVX512DQ</td>
<td>Move 8 bits mask from k1 and store the result in m8.</td></tr>
<tr>
<td>VEX.L0.0F.W1 91 /r KMOVQ m64, k1</td>
<td>MR</td>
<td>V/V</td>
<td>AVX512BW</td>
<td>Move 64 bits mask from k1 and store the result in m64.</td></tr>
<tr>
<td>VEX.L0.66.0F.W1 91 /r KMOVD m32, k1</td>
<td>MR</td>
<td>V/V</td>
<td>AVX512BW</td>
<td>Move 32 bits mask from k1 and store the result in m32.</td></tr>
<tr>
<td>VEX.L0.0F.W0 92 /r KMOVW k1, r32</td>
<td>RR</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Move 16 bits mask from r32 to k1.</td></tr>
<tr>
<td>VEX.L0.66.0F.W0 92 /r KMOVB k1, r32</td>
<td>RR</td>
<td>V/V</td>
<td>AVX512DQ</td>
<td>Move 8 bits mask from r32 to k1.</td></tr>
<tr>
<td>VEX.L0.F2.0F.W1 92 /r KMOVQ k1, r64</td>
<td>RR</td>
<td>V/I</td>
<td>AVX512BW</td>
<td>Move 64 bits mask from r64 to k1.</td></tr>
<tr>
<td>VEX.L0.F2.0F.W0 92 /r KMOVD k1, r32</td>
<td>RR</td>
<td>V/V</td>
<td>AVX512BW</td>
<td>Move 32 bits mask from r32 to k1.</td></tr>
<tr>
<td>VEX.L0.0F.W0 93 /r KMOVW r32, k1</td>
<td>RR</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Move 16 bits mask from k1 to r32.</td></tr>
<tr>
<td>VEX.L0.66.0F.W0 93 /r KMOVB r32, k1</td>
<td>RR</td>
<td>V/V</td>
<td>AVX512DQ</td>
<td>Move 8 bits mask from k1 to r32.</td></tr>
<tr>
<td>VEX.L0.F2.0F.W1 93 /r KMOVQ r64, k1</td>
<td>RR</td>
<td>V/I</td>
<td>AVX512BW</td>
<td>Move 64 bits mask from k1 to r64.</td></tr>
<tr>
<td>VEX.L0.F2.0F.W0 93 /r KMOVD r32, k1</td>
<td>RR</td>
<td>V/V</td>
<td>AVX512BW</td>
<td>Move 32 bits mask from k1 to r32.</td></tr></table>
<h3>Instruction Operand Encoding</h3>
<table>
<tr>
<td>Op/En</td>
<td>Operand 1</td>
<td>Operand 2</td></tr>
<tr>
<td>RM</td>
<td>ModRM:reg (w)</td>
<td>ModRM:r/m (r)</td></tr>
<tr>
<td>MR</td>
<td>ModRM:r/m (w, ModRM:[7:6] must not be 11b)</td>
<td>ModRM:reg (r)</td></tr>
<tr>
<td>RR</td>
<td>ModRM:reg (w)</td>
<td>ModRM:r/m (r, ModRM:[7:6] must be 11b)</td></tr></table>
<h2>Description</h2>
<p>Copies values from the source operand (second operand) to the destination operand (first operand). The source and destination operands can be mask registers, memory location or general purpose. The instruction cannot be used to transfer data between general purpose registers and or memory locations.</p>
<p>When moving to a mask register, the result is zero extended to MAX_KL size (i.e., 64 bits currently). When moving to a general-purpose register (GPR), the result is zero-extended to the size of the destination. In 32-bit mode, the default GPR destination’s size is 32 bits. In 64-bit mode, the default GPR destination’s size is 64 bits. Note that REX.W cannot be used to modify the size of the general-purpose destination.</p>
<h2>Operation</h2>
<pre>
</pre>
<strong>KMOVW</strong>
<pre>
IF *destination is a memory location*
    DEST[15:0] (cid:197) SRC[15:0]
    IF *destination is a mask register or a GPR *
        DEST (cid:197) ZeroExtension(SRC[15:0])
</pre>
<strong>KMOVB</strong>
<pre>
IF *destination is a memory location*
    DEST[7:0] (cid:197) SRC[7:0]
    IF *destination is a mask register or a GPR *
        DEST (cid:197) ZeroExtension(SRC[7:0])
</pre>
<strong>KMOVQ</strong>
<pre>
IF *destination is a memory location or a GPR*
    DEST[63:0] (cid:197) SRC[63:0]
    IF *destination is a mask register*
        DEST (cid:197) ZeroExtension(SRC[63:0])
</pre>
<strong>KMOVD</strong>
<pre>
IF *destination is a memory location*
    DEST[31:0] (cid:197) SRC[31:0]
    IF *destination is a mask register or a GPR *
        DEST (cid:197) ZeroExtension(SRC[31:0])
        </pre>
<h2>Intel C/C++ Compiler Intrinsic Equivalent</h2>
<pre>
KMOVW __mmask16 _mm512_kmov(__mmask16 a);
</pre>
<h2>Flags Affected</h2>
<p>None</p>
<h2>SIMD Floating-Point Exceptions</h2>
<p>None</p>
<h2>Other Exceptions</h2>
<p>Instructions with RR operand encoding See Exceptions Type K20.</p>
<p>Instructions with RM or MR operand encoding See Exceptions Type K21.</p>
</body>

<!-- Mirrored from shell-storm.org/x86doc/KMOVW_KMOVB_KMOVQ_KMOVD.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 Sep 2023 17:02:58 GMT -->
</html>
