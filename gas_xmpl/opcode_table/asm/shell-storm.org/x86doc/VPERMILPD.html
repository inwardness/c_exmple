<!DOCTYPE html>

<html lang="en">

<!-- Mirrored from shell-storm.org/x86doc/VPERMILPD.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 Sep 2023 17:02:58 GMT -->
<head>
<meta charset="utf-8">
<title>VPERMILPD—Permute In-Lane of Pairs of Double-Precision Floating-Point Values </title>
<meta name="Description" content="VPERMILPD—Permute In-Lane of Pairs of Double-Precision Floating-Point Values " />
<meta content="VPERMILPD, x64 opcodes, nasm opcode table, assembly opcode table, intel opcode reference, x86 opcode, instruction reference, assembly opcodes, intel semantics" name="keywords">
<meta name="Viewport" content="width=device-width, initial-scale=1.0"/>
<meta name="Robots" content="index,follow"/>
<link href="style.css" type="text/css" rel="stylesheet">
<script async src="../../www.googletagmanager.com/gtag/jsb2d6?id=G-NLNHL50HG5"></script>
<script src="https://shell-storm.org/assets/js/gtag.js"></script>
</head>
<body><a href="index.html">Back to opcode table</a>
<h1>VPERMILPD—Permute In-Lane of Pairs of Double-Precision Floating-Point Values</h1>
<table>
<tr>
<th>Opcode/Instruction</th>
<th>Op / En</th>
<th>64/32 bit Mode Support</th>
<th>CPUID Feature Flag</th>
<th>Description</th></tr>
<tr>
<td>
<p>VEX.NDS.128.66.0F38.W0 0D /r</p>
<p>VPERMILPD xmm1, xmm2, xmm3/m128</p></td>
<td>RVM</td>
<td>V/V</td>
<td>AVX</td>
<td>Permute double-precision floating-point values in xmm2 using controls from xmm3/m128 and store result in xmm1.</td></tr>
<tr>
<td>
<p>VEX.NDS.256.66.0F38.W0 0D /r</p>
<p>VPERMILPD ymm1, ymm2, ymm3/m256</p></td>
<td>RVM</td>
<td>V/V</td>
<td>AVX</td>
<td>Permute double-precision floating-point values in ymm2 using controls from ymm3/m256 and store result in ymm1.</td></tr>
<tr>
<td>
<p>EVEX.NDS.128.66.0F38.W1 0D /r</p>
<p>VPERMILPD xmm1 {k1}{z}, xmm2, xmm3/m128/m64bcst</p></td>
<td>FV-RVM</td>
<td>V/V</td>
<td>
<p>AVX512VL</p>
<p>AVX512F</p></td>
<td>Permute double-precision floating-point values in xmm2 using control from xmm3/m128/m64bcst and store the result in xmm1 using writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.NDS.256.66.0F38.W1 0D /r</p>
<p>VPERMILPD ymm1 {k1}{z}, ymm2, ymm3/m256/m64bcst</p></td>
<td>FV-RVM</td>
<td>V/V</td>
<td>
<p>AVX512VL</p>
<p>AVX512F</p></td>
<td>Permute double-precision floating-point values in ymm2 using control from ymm3/m256/m64bcst and store the result in ymm1 using writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.NDS.512.66.0F38.W1 0D /r</p>
<p>VPERMILPD zmm1 {k1}{z}, zmm2, zmm3/m512/m64bcst</p></td>
<td>FV-RVM</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Permute double-precision floating-point values in zmm2 using control from zmm3/m512/m64bcst and store the result in zmm1 using writemask k1.</td></tr>
<tr>
<td>
<p>VEX.128.66.0F3A.W0 05 /r ib</p>
<p>VPERMILPD xmm1, xmm2/m128, imm8</p></td>
<td>RM</td>
<td>V/V</td>
<td>AVX</td>
<td>Permute double-precision floating-point values in xmm2/m128 using controls from imm8.</td></tr>
<tr>
<td>
<p>VEX.256.66.0F3A.W0 05 /r ib</p>
<p>VPERMILPD ymm1, ymm2/m256, imm8</p></td>
<td>RM</td>
<td>V/V</td>
<td>AVX</td>
<td>Permute double-precision floating-point values in ymm2/m256 using controls from imm8.</td></tr>
<tr>
<td>
<p>EVEX.128.66.0F3A.W1 05 /r ib</p>
<p>VPERMILPD xmm1 {k1}{z}, xmm2/m128/m64bcst, imm8</p></td>
<td>FV-RM</td>
<td>V/V</td>
<td>
<p>AVX512VL</p>
<p>AVX512F</p></td>
<td>Permute double-precision floating-point values in xmm2/m128/m64bcst using controls from imm8 and store the result in xmm1 using writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.256.66.0F3A.W1 05 /r ib</p>
<p>VPERMILPD ymm1 {k1}{z}, ymm2/m256/m64bcst, imm8</p></td>
<td>FV-RM</td>
<td>V/V</td>
<td>
<p>AVX512VL</p>
<p>AVX512F</p></td>
<td>Permute double-precision floating-point values in ymm2/m256/m64bcst using controls from imm8 and store the result in ymm1 using writemask k1.</td></tr>
<tr>
<td>
<p>EVEX.512.66.0F3A.W1 05 /r ib</p>
<p>VPERMILPD zmm1 {k1}{z}, zmm2/m512/m64bcst, imm8</p></td>
<td>FV-RM</td>
<td>V/V</td>
<td>AVX512F</td>
<td>Permute double-precision floating-point values in zmm2/m512/m64bcst using controls from imm8 and store the result in zmm1 using writemask k1.</td></tr></table>
<h3>Instruction Operand Encoding</h3>
<table>
<tr>
<td>Op/En</td>
<td>Operand 1</td>
<td>Operand 2</td>
<td>Operand 3</td>
<td>Operand 4</td></tr>
<tr>
<td>RVM</td>
<td>ModRM:reg (w)</td>
<td>VEX.vvvv (r)</td>
<td>ModRM:r/m (r)</td>
<td>NA</td></tr>
<tr>
<td>RM</td>
<td>ModRM:reg (w)</td>
<td>ModRM:r/m (r)</td>
<td>NA</td>
<td>NA</td></tr>
<tr>
<td>FV-RVM</td>
<td>ModRM:reg (w)</td>
<td>EVEX.vvvv (r)</td>
<td>ModRM:r/m (r)</td>
<td>NA</td></tr>
<tr>
<td>FV-RM</td>
<td>ModRM:reg (w)</td>
<td>ModRM:r/m (r)</td>
<td>NA</td>
<td>NA</td></tr></table>
<h2>Description</h2>
<p><strong>Variable control version</strong></p>
<p>Permute pairs of double-precision floating-point values in the first source operand (second operand), each using a 1-bit control field residing in the corresponding quadword element of the second source operand (third operand). Permuted results are stored in the destination operand (first operand).</p>
<p>The control bits are located at bit 0 of each quadword element. Each control determines which of the source element in an input pair is selected for the destination element. Each pair of source elements must lie in the same 128-bit region as the destination.</p>
<p>EVEX version: The second source operand (third operand) is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. Permuted results are written to the destination under the writemask.</p>
<p><strong>Immediate control version</strong></p>
<p>Permute pairs of double-precision floating-point values in the first source operand (second operand), each pair using a 1-bit control field in the imm8 byte. Each element in the destination operand (first operand) use a separate control bit of the imm8 byte.</p>
<p>VEX version: The source operand is a YMM/XMM register or a 256/128-bit memory location and the destination operand is a YMM/XMM register. Imm8 byte provides the lower 4/2 bit as permute control fields.</p>
<p>EVEX version: The source operand (second operand) is a ZMM/YMM/XMM register, a 512/256/128-bit memory location or a 512/256/128-bit vector broadcasted from a 64-bit memory location. Permuted results are written to the destination under the writemask. Imm8 byte provides the lower 8/4/2 bit as permute control fields.</p>
<p>Note: For the imm8 versions, VEX.vvvv and EVEX.vvvv are reserved and must be 1111b otherwise instruction will #UD.</p>
<h2>Operation</h2>
<pre>
</pre>
<strong>VPERMILPD (EVEX immediate versions)</strong>
<pre>
(KL, VL) = (8, 512)
FOR j (cid:197) 0 TO KL-1
    i (cid:197) j * 64
    IF (EVEX.b = 1) AND (SRC1 *is memory*)
        THEN TMP_SRC1[i+63:i] (cid:197) SRC1[63:0];
        ELSE TMP_SRC1[i+63:i] (cid:197) SRC1[i+63:i];
    FI;
ENDFOR;
IF (imm8[0] = 0) THEN TMP_DEST[63:0] (cid:197) SRC1[63:0]; FI;
    IF (imm8[0] = 1) THEN TMP_DEST[63:0] (cid:197) TMP_SRC1[127:64]; FI;
        IF (imm8[1] = 0) THEN TMP_DEST[127:64] (cid:197) TMP_SRC1[63:0]; FI;
            IF (imm8[1] = 1) THEN TMP_DEST[127:64] (cid:197) TMP_SRC1[127:64]; FI;
                IF VL &gt;= 256
                    IF (imm8[2] = 0) THEN TMP_DEST[191:128] (cid:197) TMP_SRC1[191:128]; FI;
                        IF (imm8[2] = 1) THEN TMP_DEST[191:128] (cid:197) TMP_SRC1[255:192]; FI;
                            IF (imm8[3] = 0) THEN TMP_DEST[255:192] (cid:197) TMP_SRC1[191:128]; FI;
                                IF (imm8[3] = 1) THEN TMP_DEST[255:192] (cid:197) TMP_SRC1[255:192]; FI;
                                FI;
                                IF VL &gt;= 512
                                    IF (imm8[4] = 0) THEN TMP_DEST[319:256] (cid:197) TMP_SRC1[319:256]; FI;
                                        IF (imm8[4] = 1) THEN TMP_DEST[319:256] (cid:197) TMP_SRC1[383:320]; FI;
                                            IF (imm8[5] = 0) THEN TMP_DEST[383:320] (cid:197) TMP_SRC1[319:256]; FI;
                                                IF (imm8[5] = 1) THEN TMP_DEST[383:320] (cid:197) TMP_SRC1[383:320]; FI;
                                                    IF (imm8[6] = 0) THEN TMP_DEST[447:384] (cid:197) TMP_SRC1[447:384]; FI;
                                                        IF (imm8[6] = 1) THEN TMP_DEST[447:384] (cid:197) TMP_SRC1[511:448]; FI;
                                                            IF (imm8[7] = 0) THEN TMP_DEST[511:448] (cid:197) TMP_SRC1[447:384]; FI;
                                                                IF (imm8[7] = 1) THEN TMP_DEST[511:448] (cid:197) TMP_SRC1[511:448]; FI;
                                                                FI;
                                                                FOR j (cid:197) 0 TO KL-1
                                                                    i (cid:197) j * 64
                                                                    IF k1[j] OR *no writemask*
                                                                        THEN DEST[i+63:i] (cid:197) TMP_DEST[i+63:i]
                                                                        ELSE
                                                                        IF *merging-masking*
                                                                            ; merging-masking
                                                                            THEN *DEST[i+63:i] remains unchanged*
                                                                            ELSE
                                                                            ; zeroing-masking
                                                                            DEST[i+63:i] (cid:197) 0
                                                                        FI
                                                                    FI;
                                                                ENDFOR
                                                                DEST[MAX_VL-1:VL] (cid:197)(cid:3)0
</pre>
<strong>VPERMILPD (256-bit immediate version)</strong>
<pre>
IF (imm8[0] = 0) THEN DEST[63:0](cid:197)SRC1[63:0]
    IF (imm8[0] = 1) THEN DEST[63:0](cid:197)SRC1[127:64]
        IF (imm8[1] = 0) THEN DEST[127:64](cid:197)SRC1[63:0]
            IF (imm8[1] = 1) THEN DEST[127:64](cid:197)SRC1[127:64]
                IF (imm8[2] = 0) THEN DEST[191:128](cid:197)SRC1[191:128]
                    IF (imm8[2] = 1) THEN DEST[191:128](cid:197)SRC1[255:192]
                        IF (imm8[3] = 0) THEN DEST[255:192](cid:197)SRC1[191:128]
                            IF (imm8[3] = 1) THEN DEST[255:192](cid:197)SRC1[255:192]
                                DEST[MAX_VL-1:256](cid:197)0
</pre>
<strong>VPERMILPD (128-bit immediate version)</strong>
<pre>
IF (imm8[0] = 0) THEN DEST[63:0](cid:197)SRC1[63:0]
    IF (imm8[0] = 1) THEN DEST[63:0](cid:197)SRC1[127:64]
        IF (imm8[1] = 0) THEN DEST[127:64](cid:197)SRC1[63:0]
            IF (imm8[1] = 1) THEN DEST[127:64](cid:197)SRC1[127:64]
                DEST[MAX_VL-1:128](cid:197)0
</pre>
<strong>VPERMILPD (EVEX variable versions)</strong>
<pre>
(KL, VL) = (2, 128), (4, 256), (8, 512)
FOR j (cid:197) 0 TO KL-1
    i (cid:197) j * 64
    IF (EVEX.b = 1) AND (SRC2 *is memory*)
        THEN TMP_SRC2[i+63:i] (cid:197) SRC2[63:0];
        ELSE TMP_SRC2[i+63:i] (cid:197) SRC2[i+63:i];
    FI;
ENDFOR;
IF (TMP_SRC2[1] = 0) THEN TMP_DEST[63:0] (cid:197) SRC1[63:0]; FI;
    IF (TMP_SRC2[1] = 1) THEN TMP_DEST[63:0] (cid:197) SRC1[127:64]; FI;
        IF (TMP_SRC2[65] = 0) THEN TMP_DEST[127:64] (cid:197) SRC1[63:0]; FI;
            IF (TMP_SRC2[65] = 1) THEN TMP_DEST[127:64] (cid:197) SRC1[127:64]; FI;
                IF VL &gt;= 256
                    IF (TMP_SRC2[129] = 0) THEN TMP_DEST[191:128] (cid:197) SRC1[191:128]; FI;
                        IF (TMP_SRC2[129] = 1) THEN TMP_DEST[191:128] (cid:197) SRC1[255:192]; FI;
                            IF (TMP_SRC2[193] = 0) THEN TMP_DEST[255:192] (cid:197) SRC1[191:128]; FI;
                                IF (TMP_SRC2[193] = 1) THEN TMP_DEST[255:192] (cid:197) SRC1[255:192]; FI;
                                FI;
                                IF VL &gt;= 512
                                    IF (TMP_SRC2[257] = 0) THEN TMP_DEST[319:256] (cid:197) SRC1[319:256]; FI;
                                        IF (TMP_SRC2[257] = 1) THEN TMP_DEST[319:256] (cid:197) SRC1[383:320]; FI;
                                            IF (TMP_SRC2[321] = 0) THEN TMP_DEST[383:320] (cid:197) SRC1[319:256]; FI;
                                                IF (TMP_SRC2[321] = 1) THEN TMP_DEST[383:320] (cid:197) SRC1[383:320]; FI;
                                                    IF (TMP_SRC2[385] = 0) THEN TMP_DEST[447:384] (cid:197) SRC1[447:384]; FI;
                                                        IF (TMP_SRC2[385] = 1) THEN TMP_DEST[447:384] (cid:197) SRC1[511:448]; FI;
                                                            IF (TMP_SRC2[449] = 0) THEN TMP_DEST[511:448] (cid:197) SRC1[447:384]; FI;
                                                                IF (TMP_SRC2[449] = 1) THEN TMP_DEST[511:448] (cid:197) SRC1[511:448]; FI;
                                                                FI;
                                                                FOR j (cid:197) 0 TO KL-1
                                                                    i (cid:197) j * 64
                                                                    IF k1[j] OR *no writemask*
                                                                        THEN DEST[i+63:i] (cid:197) TMP_DEST[i+63:i]
                                                                        ELSE
                                                                        IF *merging-masking*
                                                                            ; merging-masking
                                                                            THEN *DEST[i+63:i] remains unchanged*
                                                                            ELSE
                                                                            ; zeroing-masking
                                                                            DEST[i+63:i] (cid:197) 0
                                                                        FI
                                                                    FI;
                                                                ENDFOR
                                                                DEST[MAX_VL-1:VL] (cid:197)(cid:3)0
</pre>
<strong>VPERMILPD (256-bit variable version)</strong>
<pre>
IF (SRC2[1] = 0) THEN DEST[63:0](cid:197)SRC1[63:0]
    IF (SRC2[1] = 1) THEN DEST[63:0](cid:197)SRC1[127:64]
        IF (SRC2[65] = 0) THEN DEST[127:64](cid:197)SRC1[63:0]
            IF (SRC2[65] = 1) THEN DEST[127:64](cid:197)SRC1[127:64]
                IF (SRC2[129] = 0) THEN DEST[191:128](cid:197)SRC1[191:128]
                    IF (SRC2[129] = 1) THEN DEST[191:128](cid:197)SRC1[255:192]
                        IF (SRC2[193] = 0) THEN DEST[255:192](cid:197)SRC1[191:128]
                            IF (SRC2[193] = 1) THEN DEST[255:192](cid:197)SRC1[255:192]
                                DEST[MAX_VL-1:256](cid:197)0
</pre>
<strong>VPERMILPD (128-bit variable version)</strong>
<pre>
IF (SRC2[1] = 0) THEN DEST[63:0](cid:197)SRC1[63:0]
    IF (SRC2[1] = 1) THEN DEST[63:0](cid:197)SRC1[127:64]
        IF (SRC2[65] = 0) THEN DEST[127:64](cid:197)SRC1[63:0]
            IF (SRC2[65] = 1) THEN DEST[127:64](cid:197)SRC1[127:64]
                DEST[MAX_VL-1:128](cid:197)0
                </pre>
<h2>Intel C/C++ Compiler Intrinsic Equivalent</h2>
<pre>
VPERMILPD __m512d _mm512_permute_pd( __m512d a, int imm);
VPERMILPD __m512d _mm512_mask_permute_pd(__m512d s, __mmask8 k, __m512d a, int imm);
VPERMILPD __m512d _mm512_maskz_permute_pd( __mmask8 k, __m512d a, int imm);
VPERMILPD __m256d _mm256_mask_permute_pd(__m256d  s, __mmask8 k, __m256d a, int imm);
VPERMILPD __m256d _mm256_maskz_permute_pd( __mmask8 k, __m256d a, int imm);
VPERMILPD __m128d _mm_mask_permute_pd(__m128d s, __mmask8 k, __m128d a, int imm);
VPERMILPD __m128d _mm_maskz_permute_pd( __mmask8 k, __m128d a, int imm);
VPERMILPD __m512d _mm512_permutevar_pd( __m512i i, __m512d a);
VPERMILPD __m512d _mm512_mask_permutevar_pd(__m512d s, __mmask8 k, __m512i i, __m512d a);
VPERMILPD __m512d _mm512_maskz_permutevar_pd( __mmask8 k, __m512i i, __m512d a);
VPERMILPD __m256d _mm256_mask_permutevar_pd(__m256d s, __mmask8 k, __m256d i, __m256d a);
VPERMILPD __m256d _mm256_maskz_permutevar_pd( __mmask8 k, __m256d i, __m256d a);
VPERMILPD __m128d _mm_mask_permutevar_pd(__m128d s, __mmask8 k, __m128d i, __m128d a);
VPERMILPD __m128d _mm_maskz_permutevar_pd( __mmask8 k, __m128d i, __m128d a);
VPERMILPD __m128d _mm_permute_pd (__m128d a, int control)
VPERMILPD __m256d _mm256_permute_pd (__m256d a, int control)
VPERMILPD __m128d _mm_permutevar_pd (__m128d a, __m128i control);
VPERMILPD __m256d _mm256_permutevar_pd (__m256d a, __m256i control);
</pre>
<h2>SIMD Floating-Point Exceptions</h2>
<p>None</p>
<h2>Other Exceptions</h2>
<p>Non-EVEX-encoded instruction, see Exceptions Type 4; additionally</p>
<table class="exception-table">
<tr>
<td>
<p>#UD</p>
<p>EVEX-encoded instruction, see Exceptions Type E4NF.</p></td>
<td>If VEX.W = 1.</td></tr>
<tr>
<td>#UD</td>
<td>If either (E)VEX.vvvv != 1111B and with imm8.</td></tr></table>
</body>

<!-- Mirrored from shell-storm.org/x86doc/VPERMILPD.html by HTTrack Website Copier/3.x [XR&CO'2014], Tue, 12 Sep 2023 17:02:58 GMT -->
</html>
